/* Copyright (c) 2015-2022, EPFL/Blue Brain Project
 * All rights reserved. Do not distribute without permission.
 *
 * This file is part of Brayns <https://github.com/BlueBrain/Brayns>
 *
 * This library is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License version 3.0 as published
 * by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
 * details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#pragma once

#include <ospray/SDK/common/Model.ih>

inline void getEEGField(const vec3f& p, uniform Model* uniform model,
                        uniform float* uniform userData, uint64 userDataSize,
                        const bool processGeometry, const float cutoff,
                        const bool normalized, float& fieldValue,
                        vec3f& fieldDirection)
{
    if (userDataSize == 0)
    {
        fieldValue = 1.f;
        fieldDirection = make_vec3f(1.f, 0.f, 0.f);
        return;
    }

    const uint64 offset =
        6; // First 6 floats are used to define the circuit bounding box
    fieldValue = 0.f;
    fieldDirection = make_vec3f(0.f);

    for (uint64 i = offset; i < userDataSize; i += 4)
    {
        const vec3f position =
            make_vec3f(userData[i + 0], userData[i + 1], userData[i + 2]);
        const vec3f v = p - position;

        bool processPoint = true;
        if (processGeometry)
        {
            Ray ray;
            ray.org = p;
            ray.dir = normalize(v);
            ray.t0 = 0.f;
            ray.t = cutoff;
            ray.primID = -1;
            ray.geomID = -1;
            ray.instID = -1;
            traceRay(model, ray);
            processPoint = (ray.geomID < 0);
        }

        if (!processPoint)
            continue;

        const float d = length(v);
        if (d < cutoff)
        {
            float d2, value;
            if (normalized)
            {
                d2 = 1.f - d / cutoff;
                value = userData[i + 3] * d2;
            }
            else
            {
                d2 = 1.f / (d * d);
                value = userData[i + 3] * d2;
            }
            fieldValue += value;
            fieldDirection = fieldDirection + v * d2;
        }
    }
}
