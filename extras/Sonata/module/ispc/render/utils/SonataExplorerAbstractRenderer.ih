/*
 * The Blue Brain BioExplorer is a tool for scientists to extract and analyse
 * scientific data from visualization
 *
 * Copyright 2020-2023 Blue Brain Project / EPFL
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <https://www.gnu.org/licenses/>.
 */

// ospray
#include <ospray/SDK/camera/PerspectiveCamera.ih>
#include <ospray/SDK/common/Model.ih>
#include <ospray/SDK/fb/FrameBuffer.ih>
#include <ospray/SDK/lights/Light.ih>
#include <ospray/SDK/render/Renderer.ih>
#include <ospray/SDK/texture/Texture2D.ih>

// obj renderer
#include "SonataExplorerMaterial.ih"

// Brayns
#include "SonataExplorerRandomGenerator.ih"

#include <module/ispc/render/utils/Consts.ih>
#include <module/ispc/render/utils/SkyBox.ih>

struct SonataExplorerAbstractRenderer
{
    Renderer super;

    // System attributes
    bool useHardwareRandomizer;

    // Rendering attributes
    const uniform Light* uniform* uniform lights;
    uint32 numLights;
    SonataExplorerMaterial* bgMaterial;
    float timestamp;
    uint32 maxBounces;
    float exposure;
};

/**
    Composes source and destination colors according to specified alpha
   correction
    @param src Source RGBA color
    @param dst Returned destination RGBA color
    @param alphaCorrection Alpha correction used to blend colors
*/
inline void composite(const varying vec4f& src, varying vec4f& dst,
                      const varying float alphaCorrection)
{
    const float alpha =
        1.f - pow(1.f - min(src.w, 1.f - 1.f / 256.f), alphaCorrection);
    const float a = alpha * (1.f - dst.w);
    dst.x = dst.x + src.x * a;
    dst.y = dst.y + src.y * a;
    dst.z = dst.z + src.z * a;
    dst.w += (alpha * (1.f - dst.w));
}

/**
    Returns the refracted vector according to the direction of the incident ray,
   he normal to the surface, and localRefraction indices
    @param direction Direction of the incident ray
    @param normal Normal to the surface
    @param n1 In localRefraction index
    @param n2 Out localRefraction index
    @return Refracted vector
*/
inline vec3f refractedVector(const varying vec3f& direction,
                             const varying vec3f& normal,
                             const varying float n1, const varying float n2)
{
    if (n2 == 0.f)
        return direction;
    const float eta = n1 / n2;
    const float cos1 = -dot(direction, normal);
    const float cos2 = 1.f - eta * eta * (1.f - cos1 * cos1);
    if (cos2 > 0.f)
        return eta * direction + (eta * cos1 - sqrt(cos2)) * normal;
    return direction;
}
