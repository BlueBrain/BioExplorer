<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.2" xml:lang="en-US">
  <compounddef id="da/ded/PathTracingRenderer_8ispc" kind="file" language="C++">
    <compoundname>PathTracingRenderer.ispc</compoundname>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline><highlight class="normal">/*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>The<sp/>Blue<sp/>Brain<sp/>BioExplorer<sp/>is<sp/>a<sp/>tool<sp/>for<sp/>scientists<sp/>to<sp/>extract<sp/>and<sp/>analyse</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>scientific<sp/>data<sp/>from<sp/>visualization</highlight></codeline>
<codeline><highlight class="normal"><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>Copyright<sp/>2020-2021<sp/>Blue<sp/>BrainProject<sp/>/<sp/>EPFL</highlight></codeline>
<codeline><highlight class="normal"><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>This<sp/>program<sp/>is<sp/>free<sp/>software:<sp/>you<sp/>can<sp/>redistribute<sp/>it<sp/>and/or<sp/>modify<sp/>it<sp/>under</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>the<sp/>terms<sp/>of<sp/>the<sp/>GNU<sp/>General<sp/>Public<sp/>License<sp/>as<sp/>published<sp/>by<sp/>the<sp/>Free<sp/>Software</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>Foundation,<sp/>either<sp/>version<sp/>3<sp/>of<sp/>the<sp/>License,<sp/>or<sp/>(at<sp/>your<sp/>option)<sp/>any<sp/>later</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>version.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>This<sp/>program<sp/>is<sp/>distributed<sp/>in<sp/>the<sp/>hope<sp/>that<sp/>it<sp/>will<sp/>be<sp/>useful,<sp/>but<sp/>WITHOUT</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>ANY<sp/>WARRANTY;<sp/>without<sp/>even<sp/>the<sp/>implied<sp/>warranty<sp/>of<sp/>MERCHANTABILITY<sp/>or<sp/>FITNESS</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>FOR<sp/>A<sp/>PARTICULAR<sp/>PURPOSE.<sp/><sp/>See<sp/>the<sp/>GNU<sp/>General<sp/>Public<sp/>License<sp/>for<sp/>more</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>details.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>You<sp/>should<sp/>have<sp/>received<sp/>a<sp/>copy<sp/>of<sp/>the<sp/>GNU<sp/>General<sp/>Public<sp/>License<sp/>along<sp/>with</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>this<sp/>program.<sp/><sp/>If<sp/>not,<sp/>see<sp/>&lt;https://www.gnu.org/licenses/&gt;.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*/</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;PathTracingRenderer.ih&quot;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;utils/BioExplorerRandomGenerator.ih&quot;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;utils/BioExplorerSkyBox.ih&quot;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">uniform<sp/>const<sp/>uint16<sp/>NB_MAX_REBOUNDS<sp/>=<sp/>20;</highlight></codeline>
<codeline><highlight class="normal">uniform<sp/>const<sp/>float<sp/>skypower<sp/>=<sp/>3.0f;</highlight></codeline>
<codeline><highlight class="normal">uniform<sp/>const<sp/>float<sp/>skypower_zerobounce<sp/>=<sp/>1.0f;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Returns<sp/>the<sp/>refracted<sp/>vector<sp/>according<sp/>to<sp/>the<sp/>direction<sp/>of<sp/>the<sp/>incident<sp/>ray,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>he<sp/>normal<sp/>to<sp/>the<sp/>surface,<sp/>and<sp/>localRefraction<sp/>indices</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>@param<sp/>direction<sp/>Direction<sp/>of<sp/>the<sp/>incident<sp/>ray</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>@param<sp/>normal<sp/>Normal<sp/>to<sp/>the<sp/>surface</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>@param<sp/>n1<sp/>In<sp/>localRefraction<sp/>index</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>@param<sp/>n2<sp/>Out<sp/>localRefraction<sp/>index</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>@return<sp/>Refracted<sp/>vector</highlight></codeline>
<codeline><highlight class="normal">*/</highlight></codeline>
<codeline><highlight class="normal">inline<sp/>vec3f<sp/>refractedVector(const<sp/>varying<sp/>vec3f&amp;<sp/>direction,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>varying<sp/>vec3f&amp;<sp/>normal,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>varying<sp/>float<sp/>n1,<sp/>const<sp/>varying<sp/>float<sp/>n2)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(n2<sp/>==<sp/>0.f)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>direction;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>float<sp/>eta<sp/>=<sp/>n1<sp/>/<sp/>n2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>float<sp/>cos1<sp/>=<sp/>-dot(direction,<sp/>normal);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>float<sp/>cos2<sp/>=<sp/>1.f<sp/>-<sp/>eta<sp/>*<sp/>eta<sp/>*<sp/>(1.f<sp/>-<sp/>cos1<sp/>*<sp/>cos1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(cos2<sp/>&gt;<sp/>0.f)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>eta<sp/>*<sp/>direction<sp/>+<sp/>(eta<sp/>*<sp/>cos1<sp/>-<sp/>sqrt(cos2))<sp/>*<sp/>normal;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>direction;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">inline<sp/>vec3f<sp/>pathTracingContribution(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>uniform<sp/>PathTracingRenderer*<sp/>uniform<sp/>self,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>varying<sp/>ScreenSample&amp;<sp/>sample,<sp/>const<sp/>varying<sp/>vec3f&amp;<sp/>sunDirection)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>vec3f<sp/>Kd;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Ray<sp/>localray<sp/>=<sp/>sample.ray;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>vec3f<sp/>accucolor<sp/>=<sp/>make_vec3f(0.f);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>vec3f<sp/>mask<sp/>=<sp/>make_vec3f(1.f);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>path<sp/>tracing<sp/>loop</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>bounces<sp/>=<sp/>0;<sp/>bounces<sp/>&lt;<sp/>3;<sp/>bounces++)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traceRay(self-&gt;super.model,<sp/>localray);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>if<sp/>ray<sp/>misses<sp/>scene<sp/>(no<sp/>hit<sp/>occurs),<sp/>return<sp/>background<sp/>colour</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(localray.geomID<sp/>&lt;<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>localray.t<sp/>=<sp/>inf;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>vec3f<sp/>bgcol<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>make_vec3f(skyboxMapping((Renderer*)self,<sp/>localray,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>self-&gt;bgMaterial))<sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>skypower;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>accucolor<sp/>=<sp/>accucolor<sp/>+<sp/>mask<sp/>*<sp/>bgcol;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>DifferentialGeometry<sp/>dg;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>postIntersect(self-&gt;super.model,<sp/>dg,<sp/>localray,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>DG_NG<sp/>|<sp/>DG_NS<sp/>|<sp/>DG_NORMALIZE<sp/>|<sp/>DG_FACEFORWARD<sp/>|</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>DG_MATERIALID<sp/>|<sp/>DG_COLOR<sp/>|<sp/>DG_TEXCOORD);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uniform<sp/>Material*<sp/>material<sp/>=<sp/>dg.material;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uniform<sp/>AdvancedMaterial*<sp/>objMaterial<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(uniform<sp/>AdvancedMaterial*)material;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(!objMaterial)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kd<sp/>=<sp/>make_vec3f(dg.color);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>foreach_unique(mat<sp/>in<sp/>objMaterial)<sp/>Kd<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>mat-&gt;Kd<sp/>*<sp/>make_vec3f(dg.color);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>compute<sp/>local<sp/>orthornormal<sp/>base<sp/>at<sp/>hitpoint</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>vec3f<sp/>N<sp/>=<sp/>dg.Ns;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>compute<sp/>ray<sp/>direction<sp/>of<sp/>uniformly<sp/>random<sp/>diffuse<sp/>ray</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>vec3f<sp/>raydir<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>getRandomVector(self-&gt;useHardwareRandomizer,<sp/>self-&gt;super.fb-&gt;size.x,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sample,<sp/>N,<sp/>self-&gt;randomNumber);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>origin<sp/>of<sp/>new<sp/>ray<sp/>in<sp/>path<sp/>is<sp/>hitpoint<sp/>of<sp/>previous<sp/>ray<sp/>in<sp/>path</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>vec3f<sp/>hitpoint<sp/>=<sp/>dg.P<sp/>+<sp/>dg.epsilon<sp/>*<sp/>N;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>setRay(localray,<sp/>hitpoint,<sp/>raydir);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>localray.t0<sp/>=<sp/>dg.epsilon;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>localray.t<sp/>=<sp/>self-&gt;aoDistance;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//***************************************</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>direct<sp/>lighting</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//***************************************</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>cosine<sp/>weighted<sp/>contribution</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>float<sp/>sunLight<sp/>=<sp/>dot(dg.Ns,<sp/>sunDirection);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(sunLight<sp/>&gt;<sp/>0.f)<sp/>//<sp/>if<sp/>surface<sp/>is<sp/>facing<sp/>light</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>create<sp/>and<sp/>trace<sp/>a<sp/>shadowray<sp/>towards<sp/>the<sp/>sun</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Ray<sp/>sunRay;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>setRay(sunRay,<sp/>hitpoint,<sp/>sunDirection);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>take<sp/>surface<sp/>color<sp/>at<sp/>this<sp/>bounce&apos;s<sp/>hitpoint<sp/>into<sp/>account</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>mask<sp/>=<sp/>mask<sp/>*<sp/>Kd;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>//<sp/>end<sp/>bounces</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>accucolor;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Renderer<sp/>a<sp/>pixel<sp/>color<sp/>according<sp/>to<sp/>a<sp/>given<sp/>location<sp/>in<sp/>the<sp/>screen<sp/>space.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>@param<sp/>self<sp/>Pointer<sp/>to<sp/>current<sp/>renderer</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>@param<sp/>sample<sp/>Screen<sp/>sample<sp/>containing<sp/>information<sp/>about<sp/>the<sp/>ray,<sp/>and<sp/>the</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>location<sp/>in<sp/>the<sp/>screen<sp/>space.</highlight></codeline>
<codeline><highlight class="normal">*/</highlight></codeline>
<codeline><highlight class="normal">inline<sp/>vec3f<sp/>PathTracingRenderer_shadeRay(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>uniform<sp/>PathTracingRenderer*<sp/>uniform<sp/>self,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>varying<sp/>ScreenSample&amp;<sp/>sample)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Ray<sp/>ray<sp/>=<sp/>sample.ray;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>vec3f<sp/>color<sp/>=<sp/>make_vec3f(0.f);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>uniform<sp/>Light*<sp/>uniform<sp/>light<sp/>=<sp/>self-&gt;lights[0];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>vec2f<sp/>s<sp/>=<sp/>make_vec2f(0.5f);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>DifferentialGeometry<sp/>dg;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>varying<sp/>Light_SampleRes<sp/>lightSample<sp/>=<sp/>light-&gt;sample(light,<sp/>dg,<sp/>s);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>vec3f<sp/>sunDirection<sp/>=<sp/>lightSample.dir;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>vec3f<sp/>radiance<sp/>=<sp/>lightSample.weight;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>float<sp/>pathOpacity<sp/>=<sp/>1.f;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>float<sp/>oldlocalRefraction<sp/>=<sp/>1.f;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>depth<sp/>=<sp/>0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>sample.z<sp/>=<sp/>inf;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>sample.alpha<sp/>=<sp/>0.f;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bool<sp/>moreRebounds<sp/>=<sp/>true;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>while<sp/>(moreRebounds<sp/>&amp;&amp;<sp/>depth<sp/>&lt;<sp/>NB_MAX_REBOUNDS<sp/>&amp;&amp;<sp/>pathOpacity<sp/>&gt;<sp/>0.f)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>float<sp/>opacity<sp/>=<sp/>1.f;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>float<sp/>reflection<sp/>=<sp/>0.f;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>float<sp/>refraction<sp/>=<sp/>1.f;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>traceRay(self-&gt;super.model,<sp/>ray);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(ray.geomID<sp/>&lt;<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>No<sp/>intersection.<sp/>Return<sp/>skybox<sp/>color</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ray.t<sp/>=<sp/>inf;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>color<sp/>=<sp/>self-&gt;showBackground</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>?<sp/>make_vec3f(skyboxMapping((Renderer*)self,<sp/>ray,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>self-&gt;bgMaterial))<sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>skypower_zerobounce</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>make_vec3f(0.f);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>No<sp/>Geometry<sp/>intersection.<sp/>No<sp/>need<sp/>to<sp/>iterate<sp/>more</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>moreRebounds<sp/>=<sp/>false;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>else,<sp/>we&apos;ve<sp/>got<sp/>a<sp/>hit!</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>DifferentialGeometry<sp/>dg;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>postIntersect(self-&gt;super.model,<sp/>dg,<sp/>ray,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>DG_NS<sp/>|<sp/>DG_NG<sp/>|<sp/>DG_NORMALIZE<sp/>|<sp/>DG_FACEFORWARD<sp/>|</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>DG_MATERIALID<sp/>|<sp/>DG_COLOR<sp/>|<sp/>DG_TEXCOORD);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>vec3f<sp/>intersection<sp/>=<sp/>dg.P;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uniform<sp/>Material*<sp/>material<sp/>=<sp/>dg.material;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uniform<sp/>AdvancedMaterial*<sp/>objMaterial<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(uniform<sp/>AdvancedMaterial*)material;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vec3f<sp/>normal<sp/>=<sp/>dg.Ns;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vec3f<sp/>Kd<sp/>=<sp/>make_vec3f(0.f);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vec3f<sp/>Ks<sp/>=<sp/>make_vec3f(0.f);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>float<sp/>Ns<sp/>=<sp/>0.f;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(!objMaterial)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kd<sp/>=<sp/>make_vec3f(dg.color);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>opacity<sp/>=<sp/>dg.color.w;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>foreach_unique(mat<sp/>in<sp/>objMaterial)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>opacity<sp/>=<sp/>mat-&gt;d;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Diffuse</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kd<sp/>=<sp/>mat-&gt;Kd;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(valid(mat-&gt;map_Kd))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>vec4f<sp/>value<sp/>=<sp/>get4f(mat-&gt;map_Kd,<sp/>dg);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kd<sp/>=<sp/>make_vec3f(value);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>opacity<sp/>*=<sp/>value.w;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Specular</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Ks<sp/>=<sp/>mat-&gt;Ks;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(valid(mat-&gt;map_Ks))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Ks<sp/>=<sp/>get3f(mat-&gt;map_Ks,<sp/>dg);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Ns<sp/>=<sp/>mat-&gt;Ns;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(valid(mat-&gt;map_Ns))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Ns<sp/>=<sp/>get1f(mat-&gt;map_Ns,<sp/>dg);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Refraction</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>refraction<sp/>=<sp/>mat-&gt;refraction;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Reflection</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>reflection<sp/>=<sp/>mat-&gt;reflection;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(valid(mat-&gt;map_reflection))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>vec4f<sp/>value<sp/>=<sp/>get4f(mat-&gt;map_reflection,<sp/>dg);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Ns<sp/>=<sp/>value.x<sp/>*<sp/>100.f;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>reflection<sp/>=<sp/>value.w;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Normal<sp/>mapping</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(valid(mat-&gt;map_Bump))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>normal<sp/>=<sp/>normalize(normal<sp/>*<sp/>get3f(mat-&gt;map_Bump,<sp/>dg));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Emissive<sp/>mapping</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(valid(mat-&gt;map_a))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Kd<sp/>=<sp/>Kd<sp/>+<sp/>get3f(mat-&gt;map_a,<sp/>dg);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>vec3f<sp/>reflectedNormal<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ray.dir<sp/>-<sp/>2.f<sp/>*<sp/>dot(ray.dir,<sp/>normal)<sp/>*<sp/>normal;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Phong<sp/>+<sp/>Blinn<sp/>shading</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>float<sp/>cosNL<sp/>=<sp/>max(0.f,<sp/>dot(sunDirection,<sp/>normal));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>float<sp/>cosLR<sp/>=<sp/>max(0.f,<sp/>dot(sunDirection,<sp/>reflectedNormal));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>vec3f<sp/>specularColor<sp/>=<sp/>Ks<sp/>*<sp/>powf(cosLR,<sp/>Ns);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Path<sp/>tracing<sp/>contribution</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>float<sp/>ao<sp/>=<sp/>self-&gt;aoStrength;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>vec3f<sp/>pathTracingColor<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ao<sp/>&gt;<sp/>0.f</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>?<sp/>Kd<sp/>*<sp/>ao<sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pathTracingContribution(self,<sp/>sample,<sp/>sunDirection)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>Kd<sp/>*<sp/>radiance<sp/>*<sp/>cosNL<sp/>+<sp/>specularColor;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Alpha<sp/>and<sp/>Z-Depth</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(depth<sp/>==<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sample.z<sp/>=<sp/>ray.t;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sample.alpha<sp/>=<sp/>opacity;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>color<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pathTracingColor<sp/>*<sp/>pathOpacity<sp/>+<sp/>color<sp/>*<sp/>(1.f<sp/>-<sp/>pathOpacity);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Prepare<sp/>ray<sp/>for<sp/>next<sp/>iteration</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bool<sp/>doRefraction<sp/>=<sp/>(opacity<sp/>&lt;<sp/>1.f);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bool<sp/>doReflection<sp/>=<sp/>(reflection<sp/>&gt;<sp/>0.f);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(doRefraction<sp/>&amp;&amp;<sp/>doReflection)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Switch<sp/>between<sp/>refraction<sp/>and<sp/>reflection</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>bool<sp/>refract<sp/>=<sp/>sample.sampleID.z<sp/>%<sp/>2<sp/>==<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>doRefraction<sp/>=<sp/>refract;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>doReflection<sp/>=<sp/>!refract;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(doRefraction)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Refraction</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vec3f<sp/>correctedNormal<sp/>=<sp/>normal;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>float<sp/>angle<sp/>=<sp/>dot(ray.dir,<sp/>correctedNormal);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(abs(refraction<sp/>-<sp/>oldlocalRefraction)<sp/>&lt;<sp/>0.001f<sp/>&amp;&amp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>angle<sp/>&gt;<sp/>0.f)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Exiting<sp/>object,<sp/>back<sp/>to<sp/>air<sp/>(refractionindex<sp/>=<sp/>1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>refraction<sp/>=<sp/>1.f;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>correctedNormal<sp/>=<sp/>correctedNormal<sp/>*<sp/>-1.f;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ray.t0<sp/>=<sp/>0.f;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ray.dir<sp/>=<sp/>refractedVector(ray.dir,<sp/>correctedNormal,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>oldlocalRefraction,<sp/>refraction);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ray.org<sp/>=<sp/>intersection<sp/>+<sp/>dg.epsilon<sp/>*<sp/>ray.dir;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pathOpacity<sp/>-=<sp/>(1.f<sp/>-<sp/>opacity);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>oldlocalRefraction<sp/>=<sp/>refraction;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++depth;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>else<sp/>if<sp/>(doReflection)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Reflection</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ray.t0<sp/>=<sp/>0.f;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ray.dir<sp/>=<sp/>reflectedNormal;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ray.org<sp/>=<sp/>intersection<sp/>+<sp/>dg.epsilon<sp/>*<sp/>reflectedNormal;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pathOpacity<sp/>-=<sp/>reflection;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++depth;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>moreRebounds<sp/>=<sp/>false;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ray.t<sp/>=<sp/>inf;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ray.primID<sp/>=<sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ray.geomID<sp/>=<sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ray.instID<sp/>=<sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>clamp(color<sp/>*<sp/>self-&gt;exposure,<sp/>make_vec3f(0.f),<sp/>make_vec3f(1.f));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>PathTracingRenderer_renderSample(uniform<sp/>Renderer*<sp/>uniform<sp/>_self,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void*<sp/>uniform<sp/>perFrameData,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>varying<sp/>ScreenSample&amp;<sp/>sample)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>uniform<sp/>PathTracingRenderer*<sp/>uniform<sp/>self<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(uniform<sp/>PathTracingRenderer<sp/>*<sp/>uniform)<sp/>_self;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>sample.ray.time<sp/>=<sp/>self-&gt;timestamp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>sample.rgb<sp/>=<sp/>PathTracingRenderer_shadeRay(self,<sp/>sample);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Exports<sp/>(called<sp/>from<sp/>C++)</highlight></codeline>
<codeline><highlight class="normal">export<sp/>void*<sp/>uniform<sp/>PathTracingRenderer_create(void*<sp/>uniform<sp/>cppE)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>uniform<sp/>PathTracingRenderer*<sp/>uniform<sp/>self<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uniform<sp/>new<sp/>uniform<sp/>PathTracingRenderer;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Renderer_Constructor(&amp;self-&gt;super,<sp/>cppE);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>self-&gt;super.renderSample<sp/>=<sp/>PathTracingRenderer_renderSample;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>self;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">export<sp/>void<sp/>PathTracingRenderer_set(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void*<sp/>uniform<sp/>_self,<sp/>void*<sp/>uniform<sp/>bgMaterial,<sp/>const<sp/>uniform<sp/>uint32<sp/>spp,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void**<sp/>uniform<sp/>lights,<sp/>uniform<sp/>int32<sp/>numLights,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>uniform<sp/>float<sp/>timestamp,<sp/>const<sp/>uniform<sp/>uint32<sp/>randomNumber,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>uniform<sp/>float<sp/>exposure,<sp/>const<sp/>uniform<sp/>float<sp/>aoStrength,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>uniform<sp/>float<sp/>aoDistance,<sp/>const<sp/>uniform<sp/>bool<sp/>useHardwareRandomizer,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>uniform<sp/>bool<sp/>showBackground)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>uniform<sp/>PathTracingRenderer*<sp/>uniform<sp/>self<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(uniform<sp/>PathTracingRenderer<sp/>*<sp/>uniform)<sp/>_self;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>self-&gt;bgMaterial<sp/>=<sp/>(uniform<sp/>AdvancedMaterial<sp/>*<sp/>uniform)<sp/>bgMaterial;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>self-&gt;timestamp<sp/>=<sp/>timestamp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>self-&gt;lights<sp/>=<sp/>(const<sp/>uniform<sp/>Light*<sp/>uniform*<sp/>uniform)lights;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>self-&gt;numLights<sp/>=<sp/>numLights;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>self-&gt;aoStrength<sp/>=<sp/>aoStrength;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>self-&gt;aoDistance<sp/>=<sp/>aoDistance;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>self-&gt;exposure<sp/>=<sp/>exposure;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>self-&gt;randomNumber<sp/>=<sp/>randomNumber;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>self-&gt;useHardwareRandomizer<sp/>=<sp/>useHardwareRandomizer;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>self-&gt;showBackground<sp/>=<sp/>showBackground;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
    </programlisting>
    <location file="/Users/favreau/git/BioExplorer/bioexplorer/core/module/ispc/render/PathTracingRenderer.ispc"/>
  </compounddef>
</doxygen>
